{"dat":{"palette":null,"tilesheet":null,"maps":{"_type":"maps","maps":[{"w":16,"h":16,"name":"map","sheet":"","data":"###$#%#&#'#(#)#*#+#,#-#~#/#0#1#2#3#4#5#6#7#8#9#:#;#<#=#>#?#@#A#B#C#D#E#F#G#H#I#J#K#L#M#N#O#P#Q#R!!|l#$#%#$!!|,$g|,!!|D#2!!|8#3#4|,#5!!|/$`!!|0#C#D|,#E!!|/##|,!!|,##!!|,#C#D|,#E!!|~##|-!!|,##|,!!#C#D|,#E!!|-##|~!!|,##|,#7|6!!|,#7|,#G|6!!|,#G|,"}]},"shaders":{"circle":{"frag":"precision mediump float; // ???\n\n// varying vec3 vColor; // varying comes from vertex shader (declared with same name)\nvarying vec2 v_uv;\n\n\nvoid main(void) {\n\tfloat x = 2.0 * v_uv.x - 1.0;\n\tfloat y = 2.0 * v_uv.y - 1.0;\n\tbool inside = x * x + y * y < 1.0;\n\tgl_FragColor = inside ? vec4(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n}","vert":"attribute vec4  a_coordinates;\n// attribute vec3 color;\nvarying   vec2 v_uv;\n\nvoid main(void) {\n    gl_Position = vec4(a_coordinates.x, a_coordinates.y, 0.0, 1.0);\n    v_uv = vec2(a_coordinates.z, a_coordinates.w);\n}"},"tilemap":{"frag":"precision mediump float; // ???\n\n// varying vec3 vColor; // varying comes from vertex shader (declared with same name)\nvarying vec2 v_uv;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_palette;\nuniform float     u_palIndex;\n\nvoid main(void) {\n\t//----------------------------------------------------------\n\t// gl_FragColor = vec4(vColor, 1.0);\n\t// gl_FragColor = color.gbra; // swap color composante\n\n\t//----------------------------------------------------------\n\tvec4 color = texture2D(u_texture, v_uv);\n\tif (color.a == 0.0) discard;\n\tgl_FragColor = texture2D(u_palette, vec2(color.g, u_palIndex));\n}","vert":"/* \n * attribute: hold input values of the vertex shader program. \n *            point to the vertex buffer objects that contains per-vertex data. \n *            Each time the vertex shader is invoked, the attributes point to VBO of different vertices.\n *\n * uniform:   hold the input data that is common for both vertex and fragment shaders,\n *            such as light position, texture coordinates, and color.\n *\n * varying:   used to pass the data from the vertex shader to the fragment shader\n */\n\nattribute vec2  a_coordinates; // attribute data comes from javascript\nattribute float a_sprite;\n// attribute vec3 color;\n\n// varying   vec3 vColor; // varying data to be passed to the fragment shader\nvarying   vec2 v_uv;\n\nvoid main(void) {\n    gl_Position = vec4(a_coordinates.x / 8.0 - 1.0, a_coordinates.y / 8.0 + 1.0, 0.0, 1.0);\n    // vColor = color;\n\n    // calculate uv coordinates from sprite index\n    float uvy = floor(a_sprite / 16.0);\n    float uvx = a_sprite - uvy * 16.0;\n    v_uv = vec2(uvx / 16.0, 1.0 - uvy / 16.0);\n}"}}},"root":"assets/","img":["palette.png","tilesheet.png"],"snd":[]}